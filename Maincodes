  return mergedList;
    }
}
package org.example.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class DataService {

    @Value("${api.financech.url}")
    private String financeChUrl;

    @Value("${api.kyc.url}")
    private String kycUrl;

    @Value("${api.token}")
    private String apiToken;

    private final ObjectMapper mapper;
    private final RestTemplate restTemplate;

    public DataService(ObjectMapper mapper, RestTemplate restTemplate) {
        this.mapper = mapper;
        this.restTemplate = restTemplate;
    }

    public List<MergedEntity> getMergedEntities() {
        List<MergedEntity> mergedList = new ArrayList<>();

        try {
            // Set headers for all API calls
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(apiToken);
            headers.setContentType(MediaType.APPLICATION_JSON);
            HttpEntity<String> httpEntity = new HttpEntity<>(headers);

            // Call FinanceCH API
            ResponseEntity<String> financeResponse = restTemplate.exchange(
                    financeChUrl, HttpMethod.GET, httpEntity, String.class);

            JsonNode root1 = mapper.readTree(financeResponse.getBody());
            JsonNode results1 = root1.path("results");

            StreamSupport.stream(results1.spliterator(), false)
                    .map(result1 -> {
                        JsonNode entityNode = result1.path("entity");
                        if (entityNode.isMissingNode()) return null;

                        Identifiers file1Identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);

                        // Parse radixData
                        List<RadixData> radixList = Optional.ofNullable(result1.path("radixData"))
                                .filter(JsonNode::isArray)
                                .map(array -> StreamSupport.stream(array.spliterator(), false)
                                        .map(node -> mapper.convertValue(node, RadixData.class))
                                        .collect(Collectors.toList()))
                                .orElse(Collections.emptyList());

                        try {
                            // Call KYC API using ptyId
                            String ptyId = file1Identifiers.getPtyId();
                            String kycUrlWithParam = kycUrl + "?ptyId=" + ptyId;

                            ResponseEntity<String> kycResponse = restTemplate.exchange(
                                    kycUrlWithParam, HttpMethod.GET, httpEntity, String.class);

                            JsonNode kycRoot = mapper.readTree(kycResponse.getBody());
                            JsonNode kycData = kycRoot.path("kycData");

                            MergedEntity merged = new MergedEntity();
                            merged.setIdentifiers(file1Identifiers);
                            merged.setRadixData(radixList);

                            // kycSites
                            Optional.ofNullable(kycData.get("kycSites"))
                                    .filter(JsonNode::isArray)
                                    .map(node -> mapper.convertValue(node, new TypeReference<List<KycSites>>() {
                                    }))
                                    .ifPresentOrElse(merged::setKycSites, () -> merged.setKycSites(null));

                            // kycSegment
                            Optional.ofNullable(kycData.get("kycSegment"))
                                    .filter(JsonNode::isTextual)
                                    .map(JsonNode::asText)
                                    .ifPresentOrElse(merged::setKycSegments, () -> merged.setKycSegments(null));

                            // riskIndustry
                            Optional.ofNullable(kycData.get("riskIndustry"))
                                    .filter(JsonNode::isArray)
                                    .map(node -> mapper.convertValue(node, new TypeReference<List<RiskIndustry>>() {
                                    }))
                                    .ifPresentOrElse(merged::setRiskIndustry, () -> merged.setRiskIndustry(null));

                            return merged;

                        } catch (Exception e) {
                            System.err.println("Error for ptyId: " + file1Identifiers.getPtyId() + " â€” " + e.getMessage());
                            return null;
                        }

                    })
                    .filter(Objects::nonNull)
                    .forEach(mergedList::add);

        } catch (Exception e) {
            System.err.println("Error retrieving FinanceCH data: " + e.getMessage());
            e.printStackTrace();
        }

        return mergedList;
    }
}
