// This is a full Spring Boot mock version
// It bypasses the actual API call and uses mock FinanceCH and KYC data
// Useful when real API domain (e.g., api-int.staging.echonet) is unreachable due to network

// === application.properties ===

api.financech.url=http://localhost:8080/mock/financech
api.kyc.url=http://localhost:8080/mock/kyc
api.token=dummy-token


// === MergedEntity.java ===
package org.example.model;

import java.util.List;

public class MergedEntity {
    private Identifiers identifiers;
    private List<RadixData> radixData;
    private List<KycSites> kycSites;
    private String kycSegments;
    private List<RiskIndustry> riskIndustry;

    // Getters and Setters
}


// === Identifiers.java, RadixData.java, KycSites.java, RiskIndustry.java ===
// Create these model classes with standard fields + getters/setters based on your JSON


// === DataService.java ===
package org.example.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class DataService {

    @Value("${api.financech.url}")
    private String financeChUrl;

    @Value("${api.kyc.url}")
    private String kycUrl;

    private final ObjectMapper mapper = new ObjectMapper();
    private final RestTemplate restTemplate = new RestTemplate();

    public List<MergedEntity> getMergedEntities() {
        List<MergedEntity> mergedList = new ArrayList<>();
        try {
            JsonNode financeRoot = mapper.readTree(restTemplate.getForObject(financeChUrl, String.class));
            JsonNode kycRoot = mapper.readTree(restTemplate.getForObject(kycUrl, String.class));

            JsonNode financeResults = financeRoot.path("results");
            JsonNode kycResults = kycRoot.path("results");

            Map<String, JsonNode> kycMap = new HashMap<>();
            for (JsonNode result : kycResults) {
                JsonNode ids = result.path("identifiers");
                if (ids.isArray() && ids.size() > 0) {
                    Identifiers identifiers = mapper.convertValue(ids.get(0), Identifiers.class);
                    kycMap.put(identifiers.getPtyId(), result.path("kycData"));
                }
            }

            for (JsonNode result : financeResults) {
                JsonNode entity = result.path("entity");
                Identifiers identifiers = mapper.convertValue(entity.path("identifiers"), Identifiers.class);
                String ptyId = identifiers.getPtyId();

                List<RadixData> radixList = Optional.ofNullable(result.path("radixData"))
                        .filter(JsonNode::isArray)
                        .map(arr -> StreamSupport.stream(arr.spliterator(), false)
                                .map(node -> mapper.convertValue(node, RadixData.class))
                                .collect(Collectors.toList()))
                        .orElse(Collections.emptyList());

                MergedEntity merged = new MergedEntity();
                merged.setIdentifiers(identifiers);
                merged.setRadixData(radixList);

                JsonNode kycData = kycMap.get(ptyId);
                if (kycData != null) {
                    Optional.ofNullable(kycData.get("kycSites"))
                            .filter(JsonNode::isArray)
                            .map(node -> mapper.convertValue(node, new TypeReference<List<KycSites>>() {}))
                            .ifPresentOrElse(merged::setKycSites, () -> merged.setKycSites(null));

                    Optional.ofNullable(kycData.get("kycSegment"))
                            .filter(JsonNode::isTextual)
                            .map(JsonNode::asText)
                            .ifPresentOrElse(merged::setKycSegments, () -> merged.setKycSegments(null));

                    Optional.ofNullable(kycData.get("riskIndustry"))
                            .filter(JsonNode::isArray)
                            .map(node -> mapper.convertValue(node, new TypeReference<List<RiskIndustry>>() {}))
                            .ifPresentOrElse(merged::setRiskIndustry, () -> merged.setRiskIndustry(null));
                }

                mergedList.add(merged);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return mergedList;
    }
}


// === MockApiController.java ===
package org.example.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Map;

@RestController
public class MockApiController {

    @GetMapping("/mock/financech")
    public Map<String, Object> mockFinanceCh() {
        // Return mock JSON data with 'results' containing 'entity' and 'radixData'
        return Map.of("results", List.of(
                Map.of("entity", Map.of("identifiers", Map.of("ptyId", "123")),
                       "radixData", List.of(Map.of("dataId", "r1", "value", "radixValue")))
        ));
    }

    @GetMapping("/mock/kyc")
    public Map<String, Object> mockKyc() {
        return Map.of("results", List.of(
                Map.of("identifiers", List.of(Map.of("ptyId", "123")),
                       "kycData", Map.of(
                           "kycSites", List.of(Map.of("siteId", "s1")),
                           "kycSegment", "SegmentA",
                           "riskIndustry", List.of(Map.of("code", "RI1", "description", "RiskDesc"))
                       ))
        ));
    }
}


// === DataLoader.java ===
package org.example.loader;

import org.example.model.MergedEntity;
import org.example.service.DataService;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class DataLoader implements ApplicationRunner {
    private final DataService dataService;

    public DataLoader(DataService dataService) {
        this.dataService = dataService;
    }

    @Override
    public void run(ApplicationArguments args) {
        List<MergedEntity> result = dataService.getMergedEntities();
        result.forEach(System.out::println);
    }
}
