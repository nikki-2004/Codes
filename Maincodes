@Service
public class DataService {

    @Value("${financech.api.url}")
    private String financeApiUrl;

    private final RestTemplate restTemplate = new RestTemplate();
    private final ObjectMapper mapper = new ObjectMapper();

    public List<MergedEntity> getMergedEntities() {
        List<MergedEntity> mergedList = new ArrayList<>();

        try {
            // Step 1: Get JSON from API
            String json = restTemplate.getForObject(financeApiUrl, String.class);

            // Step 2: Read root nodes
            JsonNode root = mapper.readTree(json);
            JsonNode result1 = root.path("result");   // Contains entity + radixData
            JsonNode result2 = root.path("result2");  // Contains identifiers + kycData

            // Step 3: Loop through result1 (finance records)
            for (JsonNode record : result1) {
                JsonNode entityNode = record.path("entity");
                Identifiers identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);

                List<RadixData> radixList = Optional.ofNullable(record.path("radixData"))
                        .filter(JsonNode::isArray)
                        .map(array -> StreamSupport.stream(array.spliterator(), false)
                                .map(node -> mapper.convertValue(node, RadixData.class))
                                .collect(Collectors.toList()))
                        .orElse(Collections.emptyList());

                // Step 4: Match with result2 using ptyId
                JsonNode matched = StreamSupport.stream(result2.spliterator(), false)
                        .filter(node -> {
                            JsonNode ids = node.path("identifiers");
                            return ids.isArray() && ids.size() > 0 &&
                                   identifiers.getPtyId().equals(
                                       mapper.convertValue(ids.get(0), Identifiers.class).getPtyId());
                        })
                        .findFirst()
                        .orElse(null);

                MergedEntity merged = new MergedEntity();
                merged.setIdentifiers(identifiers);
                merged.setRadixData(radixList);

                if (matched != null) {
                    JsonNode kycData = matched.path("kycData");

                    // Set kycSites
                    Optional.ofNullable(kycData.get("kycSite"))
                            .filter(JsonNode::isArray)
                            .map(node -> mapper.convertValue(node, new TypeReference<List<KycSites>>() {}))
                            .ifPresent(merged::setKycSites);

                    // Set kycSegment
                    Optional.ofNullable(kycData.get("kycSegment"))
                            .filter(JsonNode::isTextual)
                            .map(JsonNode::asText)
                            .ifPresent(merged::setKycSegments);

                    // Set riskIndustry
                    Optional.ofNullable(kycData.get("riskIndustry"))
                            .filter(JsonNode::isArray)
                            .map(node -> mapper.convertValue(node, new TypeReference<List<RiskIndustry>>() {}))
                            .ifPresent(merged::setRiskIndustry);
                }

                mergedList.add(merged);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return mergedList;
    }
}
