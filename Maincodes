public List<MergedEntity> getMergedEntities() {
    List<MergedEntity> mergedList = new ArrayList<>();

    try {
        fetchAuthToken();

        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(this.token);
        headers.add("Accept", "*/*;version=gamma");
        HttpEntity<String> request = new HttpEntity<>(headers);

        // Step 1: Fetch FinanceCH data
        ResponseEntity<String> financeResponse = restTemplate.exchange(financeChUrl, HttpMethod.GET, request, String.class);
        if (!financeResponse.getStatusCode().is2xxSuccessful()) {
            throw new RuntimeException("FinanceCH API returned error: " + financeResponse.getStatusCode());
        }

        JsonNode financeRoot = mapper.readTree(financeResponse.getBody());
        JsonNode financeResults = financeRoot.path("results");

        for (JsonNode financeResult : financeResults) {
            try {
                JsonNode entityNode = financeResult.path("entity");
                if (entityNode.isMissingNode()) continue;

                Identifiers identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);
                String ptyId = identifiers.getPtyId();

                // Step 2: Fetch KYC data dynamically for each ptyId
                String dynamicKycUrl = kycUrl + "?ptyId=" + ptyId;
                ResponseEntity<String> kycResponse = restTemplate.exchange(dynamicKycUrl, HttpMethod.GET, request, String.class);

                if (!kycResponse.getStatusCode().is2xxSuccessful()) {
                    System.out.println("No KYC data found for ptyId: " + ptyId + " → Merged Entity: null");
                    continue;
                }

                JsonNode kycRoot = mapper.readTree(kycResponse.getBody());
                JsonNode kycResults = kycRoot.path("results");

                if (!kycResults.isArray() || kycResults.size() == 0) {
                    System.out.println("No KYC data found for ptyId: " + ptyId + " → Merged Entity: null");
                    continue;
                }

                JsonNode kycResult = kycResults.get(0); // assume one match

                MergedEntity merged = new MergedEntity();
                merged.setIdentifiers(identifiers);

                List<RadixData> radixDataList = Optional.ofNullable(financeResult.path("radixData"))
                        .filter(JsonNode::isArray)
                        .map(array -> StreamSupport.stream(array.spliterator(), false)
                                .map(node -> mapper.convertValue(node, RadixData.class))
                                .collect(Collectors.toList()))
                        .orElse(Collections.emptyList());
                merged.setRadixData(radixDataList);

                JsonNode kycData = getFieldIgnoreCase(kycResult, "kycData");

                if (kycData != null) {
                    Optional.ofNullable(getFieldIgnoreCase(kycData, "kycSegment"))
                            .filter(JsonNode::isTextual)
                            .map(JsonNode::asText)
                            .ifPresent(merged::setKycSegments);

                    Optional.ofNullable(getFieldIgnoreCase(kycData, "riskIndustry"))
                            .filter(JsonNode::isArray)
                            .map(array -> mapper.convertValue(array, new TypeReference<List<RiskIndustry>>() {}))
                            .ifPresent(merged::setRiskIndustry);

                    Optional.ofNullable(getFieldIgnoreCase(kycData, "kycSites"))
                            .filter(JsonNode::isArray)
                            .map(array -> mapper.convertValue(array, new TypeReference<List<KycSites>>() {}))
                            .ifPresent(merged::setKycSites);
                }

                mergedList.add(merged);
                System.out.println("Merged Entity for ptyId: " + ptyId + " → " + merged);

            } catch (Exception ex) {
                System.out.println("No KYC data found (error) for ptyId: " + ex.getMessage() + " → Merged Entity: null");
                ex.printStackTrace();
            }
        }

    } catch (Exception e) {
        System.err.println("Error during FinanceCH processing: " + e.getMessage());
        throw new RuntimeException("Aborting: " + e.getMessage(), e);
    }

    return mergedList;
}
