package org.example.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class DataService {

Â  Â  private final RestTemplate restTemplate;
Â  Â  private final ObjectMapper mapper;

Â  Â  @Value("${api.financech.url}")
Â  Â  private String financeChUrl;

Â  Â  @Value("${api.kyc.url}")
Â  Â  private String kycUrl;

Â  Â  @Value("${auth.token.url}")
Â  Â  private String authTokenUrl;

Â  Â  @Value("${auth.basic.auth}")
Â  Â  private String basicAuth;

Â  Â  private String token;

Â  Â  public DataService(RestTemplate restTemplate) {
Â  Â  Â  Â  this.restTemplate = restTemplate;
Â  Â  Â  Â  this.mapper = new ObjectMapper();
Â  Â  }

Â  Â  private void fetchAuthToken() {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  System.out.println("Fetching token from: " + authTokenUrl);

Â  Â  Â  Â  Â  Â  HttpHeaders headers = new HttpHeaders();
Â  Â  Â  Â  Â  Â  headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
Â  Â  Â  Â  Â  Â  headers.set("Authorization", basicAuth);
Â  Â  Â  Â  Â  Â  headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));

Â  Â  Â  Â  Â  Â  HttpEntity<String> request = new HttpEntity<>("", headers);
Â  Â  Â  Â  Â  Â  ResponseEntity<String> response = restTemplate.postForEntity(authTokenUrl, request, String.class);

Â  Â  Â  Â  Â  Â  // âœ… Check for 200 OK
Â  Â  Â  Â  Â  Â  if (!response.getStatusCode().is2xxSuccessful()) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new RuntimeException("Auth token API returned error: " + response.getStatusCode());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  JsonNode json = mapper.readTree(response.getBody());
Â  Â  Â  Â  Â  Â  this.token = json.path("access_token").asText();

Â  Â  Â  Â  Â  Â  if (token == null || token.isBlank()) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new RuntimeException("Token not found in response");
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  System.out.println("Token fetched and stored: " + token);
Â  Â  Â  Â  } catch (Exception e) {
Â  Â  Â  Â  Â  Â  throw new RuntimeException("Failed to fetch token: " + e.getMessage(), e);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  public List<MergedEntity> getMergedEntities() {
Â  Â  Â  Â  List<MergedEntity> mergedList = new ArrayList<>();

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  fetchAuthToken();

Â  Â  Â  Â  Â  Â  HttpHeaders headers = new HttpHeaders();
Â  Â  Â  Â  Â  Â  headers.setBearerAuth(this.token);
Â  Â  Â  Â  Â  Â  headers.add("Accept", "*/*;version=gamma");
Â  Â  Â  Â  Â  Â  HttpEntity<String> request = new HttpEntity<>(headers);

Â  Â  Â  Â  Â  Â  // âœ… Fetch FinanceCH data
Â  Â  Â  Â  Â  Â  ResponseEntity<String> financeResponse = restTemplate.exchange(financeChUrl, HttpMethod.GET, request, String.class);

Â  Â  Â  Â  Â  Â  if (!financeResponse.getStatusCode().is2xxSuccessful()) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new RuntimeException("FinanceCH API returned error: " + financeResponse.getStatusCode());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  JsonNode financeRoot = mapper.readTree(financeResponse.getBody());
Â  Â  Â  Â  Â  Â  JsonNode financeResults = financeRoot.path("results");

Â  Â  Â  Â  Â  Â  // âœ… Fetch KYC data
Â  Â  Â  Â  Â  Â  ResponseEntity<String> kycResponse = restTemplate.exchange(kycUrl, HttpMethod.GET, request, String.class);

Â  Â  Â  Â  Â  Â  if (!kycResponse.getStatusCode().is2xxSuccessful()) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new RuntimeException("KYC API returned error: " + kycResponse.getStatusCode());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  JsonNode kycRoot = mapper.readTree(kycResponse.getBody());
Â  Â  Â  Â  Â  Â  JsonNode kycResults = kycRoot.path("results");

Â  Â  Â  Â  Â  Â  Map<String, JsonNode> kycMap = new HashMap<>();

Â  Â  Â  Â  Â  Â  // ðŸ”„ Map KYC data
Â  Â  Â  Â  Â  Â  for (JsonNode kycResult : kycResults) {
Â  Â  Â  Â  Â  Â  Â  Â  JsonNode identifiersNode = kycResult.path("identifiers");
Â  Â  Â  Â  Â  Â  Â  Â  if (identifiersNode.isArray() && identifiersNode.size() > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Identifiers identifiers = mapper.convertValue(identifiersNode.get(0), Identifiers.class);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  JsonNode kycData = getFieldIgnoreCase(kycResult, "kycData");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (kycData != null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  kycMap.put(identifiers.getPtyId(), kycData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // ðŸ”— Merge records
Â  Â  Â  Â  Â  Â  for (JsonNode financeResult : financeResults) {
Â  Â  Â  Â  Â  Â  Â  Â  JsonNode entityNode = financeResult.path("entity");
Â  Â  Â  Â  Â  Â  Â  Â  if (entityNode.isMissingNode()) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Identifiers identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);
Â  Â  Â  Â  Â  Â  Â  Â  String ptyId = identifiers.getPtyId();

Â  Â  Â  Â  Â  Â  Â  Â  if (kycMap.containsKey(ptyId)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  MergedEntity merged = new MergedEntity();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  merged.setIdentifiers(identifiers);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  List<RadixData> radixDataList = Optional.ofNullable(financeResult.path("radixData"))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .filter(JsonNode::isArray)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(array -> StreamSupport.stream(array.spliterator(), false)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(node -> mapper.convertValue(node, RadixData.class))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .collect(Collectors.toList()))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .orElse(Collections.emptyList());
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  merged.setRadixData(radixDataList);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  JsonNode kycData = kycMap.get(ptyId);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Optional.ofNullable(getFieldIgnoreCase(kycData, "kycSegment"))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .filter(JsonNode::isTextual)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(JsonNode::asText)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .ifPresent(merged::setKycSegments);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Optional.ofNullable(getFieldIgnoreCase(kycData, "riskIndustry"))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .filter(JsonNode::isArray)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(array -> mapper.convertValue(array, new TypeReference<List<RiskIndustry>>() {}))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .ifPresent(merged::setRiskIndustry);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Optional.ofNullable(getFieldIgnoreCase(kycData, "kycSites"))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .filter(JsonNode::isArray)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(array -> mapper.convertValue(array, new TypeReference<List<KycSites>>() {}))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .ifPresent(merged::setKycSites);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mergedList.add(merged);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } catch (Exception e) {
Â  Â  Â  Â  Â  Â  System.err.println("Error retrieving merged entities: " + e.getMessage());
Â  Â  Â  Â  Â  Â  e.printStackTrace();
Â  Â  Â  Â  Â  Â  throw new RuntimeException("Aborting due to failure: " + e.getMessage(), e);
Â  Â  Â  Â  }

Â  Â  Â  Â  return mergedList;
Â  Â  }

Â  Â  // ðŸ”Ž Helper method to handle fields with case-insensitive names
Â  Â  private JsonNode getFieldIgnoreCase(JsonNode node, String fieldName) {
Â  Â  Â  Â  if (node == null || !node.isObject()) return null;

Â  Â  Â  Â  Iterator<String> fieldNames = node.fieldNames();
Â  Â  Â  Â  while (fieldNames.hasNext()) {
Â  Â  Â  Â  Â  Â  String key = fieldNames.next();
Â  Â  Â  Â  Â  Â  if (key.equalsIgnoreCase(fieldName)) {
Â  Â  Â  Â  Â  Â  Â  Â  return node.get(key);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return null;
Â  Â  }
}
