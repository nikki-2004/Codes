package org.example.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.example.Model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class DataService {

    @Value("${api1.url}")
    private String api1Url;

    @Value("${api2.url}")
    private String api2Url;

    private final RestTemplate restTemplate;
    private final ObjectMapper mapper;

    public DataService() {
        this.restTemplate = new RestTemplate();
        this.mapper = new ObjectMapper();
    }

    public List<MergedEntity> getMergedEntities() {
        List<MergedEntity> mergedList = new ArrayList<>();

        try {
            // Step 1: Fetch JSON from APIs
            String json1 = restTemplate.getForObject(api1Url, String.class);
            String json2 = restTemplate.getForObject(api2Url, String.class);

            // Step 2: Parse JSON
            JsonNode root1 = mapper.readTree(json1);
            JsonNode root2 = mapper.readTree(json2);

            JsonNode results1 = root1.path("results");
            JsonNode results2 = root2.path("results");

            StreamSupport.stream(results1.spliterator(), false)
                .map(result1 -> {
                    JsonNode entityNode = result1.path("entity");
                    if (entityNode.isMissingNode()) return null;

                    Identifiers file1Identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);
                    List<RadixData> radixList = Optional.ofNullable(result1.path("radixData"))
                        .filter(JsonNode::isArray)
                        .map(array -> StreamSupport.stream(array.spliterator(), false)
                                .map(node -> mapper.convertValue(node, RadixData.class))
                                .collect(Collectors.toList()))
                        .orElse(Collections.emptyList());

                    return results2.findValues("identifiers").stream()
                        .filter(array -> array.isArray() && array.size() > 0)
                        .map(array -> mapper.convertValue(array.get(0), Identifiers.class))
                        .filter(file2Identifiers -> file1Identifiers.getPtyId().equals(file2Identifiers.getPtyId()))
                        .findFirst()
                        .map(matchedIdentifier -> {
                            MergedEntity merged = new MergedEntity();
                            merged.setIdentifiers(file1Identifiers);
                            merged.setRadixData(radixList);

                            JsonNode matchingResult2 = StreamSupport.stream(results2.spliterator(), false)
                                .filter(r -> {
                                    JsonNode idNode = r.get("identifiers");
                                    return idNode != null && idNode.isArray() && idNode.size() > 0 &&
                                        file1Identifiers.getPtyId().equals(
                                            mapper.convertValue(idNode.get(0), Identifiers.class).getPtyId());
                                })
                                .findFirst()
                                .orElse(null);

                            Optional.ofNullable(matchingResult2)
                                .map(r -> r.get("kycData"))
                                .ifPresentOrElse(kycData -> {
                                    Optional.ofNullable(kycData.get("kycSite"))
                                        .filter(JsonNode::isArray)
                                        .map(node -> mapper.convertValue(node, new TypeReference<List<KycSites>>() {}))
                                        .ifPresentOrElse(merged::setKycSites, () -> merged.setKycSites(null));

                                    Optional.ofNullable(kycData.get("kycSegment"))
                                        .filter(JsonNode::isTextual)
                                        .map(JsonNode::asText)
                                        .ifPresentOrElse(merged::setKycSegments, () -> merged.setKycSegments(null));

                                    Optional.ofNullable(kycData.get("riskIndustry"))
                                        .filter(JsonNode::isArray)
                                        .map(node -> mapper.convertValue(node, new TypeReference<List<RiskIndustry>>() {}))
                                        .ifPresentOrElse(merged::setRiskIndustry, () -> merged.setRiskIndustry(null));
                                }, () -> {
                                    merged.setKycSites(null);
                                    merged.setKycSegments(null);
                                    merged.setRiskIndustry(null);
                                });

                            return merged;
                        })
                        .orElse(null);
                })
                .filter(Objects::nonNull)
                .forEach(mergedList::add);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return mergedList;
    }
}
