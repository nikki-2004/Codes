public List<MergedEntity> getMergedEntities() {
    List<MergedEntity> mergedList = new ArrayList<>();
    try {
        // Prepare headers with token
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(token);
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        HttpEntity<String> entity = new HttpEntity<>(headers);

        // --- Fetch FinanceCH data ---
        ResponseEntity<byte[]> financeResponse = restTemplate.exchange(
                financeChUrl, HttpMethod.GET, entity, byte[].class);
        JsonNode financeRoot = mapper.readTree(financeResponse.getBody());
        JsonNode financeResults = financeRoot.path("results");

        // --- Fetch KYC data ---
        ResponseEntity<byte[]> kycResponse = restTemplate.exchange(
                kycUrl, HttpMethod.GET, entity, byte[].class);
        JsonNode kycRoot = mapper.readTree(kycResponse.getBody());
        JsonNode kycResults = kycRoot.path("results");

        // Map KYC by ptyId
        Map<String, JsonNode> kycMap = new HashMap<>();
        for (JsonNode result : kycResults) {
            JsonNode ids = result.path("identifiers");
            if (!ids.isMissingNode()) {
                Identifiers identifiers = mapper.convertValue(ids, Identifiers.class);
                String ptyId = identifiers.getPtyId();
                JsonNode kycDataNode = result.path("kycData");
                if (!kycDataNode.isMissingNode() && ptyId != null) {
                    kycMap.put(ptyId, kycDataNode);
                }
            }
        }

        // Loop over FinanceCH results
        for (JsonNode result : financeResults) {
            JsonNode entityNode = result.path("entity");
            if (entityNode.isMissingNode()) continue;

            Identifiers identifiers = mapper.convertValue(entityNode.path("identifiers"), Identifiers.class);
            String ptyId = identifiers.getPtyId();

            List<RadixData> radixData = Optional.ofNullable(result.path("radixData"))
                    .filter(JsonNode::isArray)
                    .map(array -> StreamSupport.stream(array.spliterator(), false)
                            .map(node -> mapper.convertValue(node, RadixData.class))
                            .collect(Collectors.toList()))
                    .orElse(Collections.emptyList());

            MergedEntity merged = new MergedEntity();
            merged.setIdentifiers(identifiers);
            merged.setRadixData(radixData);

            // Merge KYC fields using kycData
            JsonNode kycData = kycMap.get(ptyId);
            if (kycData != null) {
                Optional.ofNullable(kycData.get("kycSites"))
                        .filter(JsonNode::isArray)
                        .map(node -> mapper.convertValue(node, new TypeReference<List<KycSites>>() {}))
                        .ifPresent(merged::setKycSites);

                Optional.ofNullable(kycData.get("kycSegment"))
                        .filter(JsonNode::isTextual)
                        .map(JsonNode::asText)
                        .ifPresent(merged::setKycSegments);

                Optional.ofNullable(kycData.get("riskIndustry"))
                        .filter(JsonNode::isArray)
                        .map(node -> mapper.convertValue(node, new TypeReference<List<RiskIndustry>>() {}))
                        .ifPresent(merged::setRiskIndustry);
            }

            mergedList.add(merged);
        }

    } catch (Exception e) {
        System.err.println("Error retrieving merged entities: " + e.getMessage());
        e.printStackTrace();
    }
    return mergedList;
}
